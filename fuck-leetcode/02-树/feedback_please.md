# 我与递归的故事

为什么我要直接从递归开始介绍我的刷题之旅呢？因为当我刷过了一些题目之后，我慢慢的发现递归真的是解题的一个大杀器。使用递归不仅可以解决有关树、图等题目，还可以解决链表、字符串、排列组合、动态规划等题目，甚至有很多问题只能通过递归进行求解。虽然递归思想很有用也很好用，但是如何编写出正确的递归代码却是一个痛苦的过程。

其实对于递归一开始我是拒绝的，一见到别人的递归代码就直接跳过反而看迭代的代码，但该来的总会来，所以那就做真的勇士，敢于面对惨淡的人生。

<img src="https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200416184418.png" style="zoom:50%;" />

慢慢的，我开始看并且尝试去理解别人的递归代码，然后我开始编写递归代码；在经过编写了大量的递归代码后，最后我总结出编写递归代码的套路。

在学习递归的这条路上，用电影《肖申克的救赎》中的一段话形容我的心路历程很合适。

> These walls are kind of funny like that. First you hate them, then you get used to them. Enough time passed， get so you depend on them. That's institution alized.
>
> 这些高墙真的很有趣，一开始你憎恨他们；然后你慢慢的习惯他们；最后你不得不依赖他们而生存，这就是体制化。

不过用中文描述我的心路历程就很简单了。

![](https://cdn.jsdelivr.net/gh/jackymxp/image-bed/design-pattern/u=1882634846,423550706&fm=26&gp=0.jpg)

理解了递归，才会发现递归真香，接下来结合我自己的经验，说一下如何理解和使用递归？

**理解递归最重要的一点就是放弃，放弃刨根问底的精神，不要深究在递归函数内部是怎么运行的，而是信任递归能够解决问题**，这就是如何理解递归的核心。==信任的基础在于数学。==

![](https://tva1.sinaimg.cn/large/007S8ZIlly1gdvuk5zq5kj30cf089aak.jpg)

当我慢慢的理解了递归，我发现递归解决问题的这种感觉似曾相识，什么时候有过这种感觉呢？在初恋的年纪学习**数学归纳法**的时候，曾经有过这种不需要刨根问题的精神。所以为了理解递归，先来回顾一下用数学归纳法解题的步骤：

>   1.  当$n=1$时，显然成立。
>   2.  假设当$n=k$时，依然成立。
>   3.  证明当$n=k+1$时，等式是成立的，这一步比较困难。

数学归纳法的**核心就是在$f(n-1$的基础上，找出$f(n)$和$f(n-1)$之间的关系**。

其实编写递归的套路和数学归纳法如出一辙。按照数学归纳法的三个步骤，给出编写递归的四点，这里先说三点，最后一点放在文章的最后。

>   1.  **明确编写的递归函数功能、递归函数参数以及返回值。**对应数学归纳法中的第二条。当给递归函数传入不同参数时，根据定义的递归函数的功能，函数应该返回什么结果，这一点是一直都要明确的。
>   2.  **明确递归函数的退出条件**。对应数学归纳法中的第一条。如果没有退出条件，就一直递归下去，结果就是爆栈。一般来说，这点相对来讲比较简单。这一点
>   3.  **如何把分割数据为多层，并梳理清楚层与层之间的关系**。对应数学归纳法中的第三条。在数学归纳法中，我们要找出$f(n)$和$f(n-1)$之间的关系，其实就是层与层之间的关系。在递归中，一般是将一个规模为$n$的数据拆分成两个或者多个规模更小的数据，假设拆分成规模为$n-1$和$1$的两部分。其中将$n-1$部分仍然作为递归的参数，根据定义的递归函数的功能，$n-1$部分就得到了期望的答案。这里切记千万不要深究递归函数是怎么把$n-1$部分变成期望的答案的，只要知道递归函数可以达到我们期望的目的就行了。前面说的放弃，就是在这里放弃思考如何实现$n-1$部分的。接下来的工作就是在已经得到期望答案的规模为$n-1$数据的基础上，与规模为$1$的数据进行适当的融合，使整体变成期望的答案。当然我们也可以将规模为$n$的数据拆分成规模为$n-2$和$2$两个部分，甚至是规模为$n/2$和$n/2$两个部分，比如归并排序。那么在快排中，把数据分成了$n-k$和$k$两个部分，其中$k$是每次`partition`后的索引值。但是具体问题还应具体分析。我们把我们期望的答案或者结构看成是一层，将数据规模更小的那部分用递归函数作用后的结果看作一层，其实还是寻找层与层之间的关系。

写了这么多苍白无力的文字和解释，还是用一个小例子解释一下数学归纳法和递归更为清楚。

# 递归函数核心：层与层之间的关系

## 阶乘问题

>    使用递归的方法求$n$的阶乘。

按照前面给出的递归的三个步骤，盘这个题。

**1. 定义递归函数`int factorial(int n)`功能以及返回值**：

定义递归函数功能是计算$n$的阶乘。也就是说，当传入$n$的时候，就计算$n$的阶乘；当传入$n-1$的时候，就计算$n-1$的阶乘。这样说是不是很简单。

**2. 寻找递归函数退出条件和返回值**

因为要将$n$拆成两个部分，所以递归退出的条件就是$n$不能分成两个部分的时候，也就是$n=0$时，就是递归退出条件，数学知识我们都知道，$0!=1$，写成代码。

```cpp
if(n == 0)
    return 1;
```

**3. 如何把分割数据为多层，并梳理清楚层与层之间的关系**

想一下，这里如何递减数据规模呢，或者把数据分为多层呢？

想要计算$n$的阶乘，那么如果知道了$n-1$的阶乘，怎么计算$n$的阶乘呢？当然这是一个so easy的数学问题，不管你知不知道，反正我是知道，$n! = (n-1)! * n$。那么问题来了，如何计算$n-1$的阶乘呢？额，如果你从头看到了这里还不知道怎么计算$n-1$的阶乘，那你从头再看一遍吧。这不是定义的递归函数功能嘛，调用`factorial(n-1)`就完成了$n-1$阶乘的计算。在这里请放弃思考为什么调用`factorial(n-1)`就完成了$n-1$阶乘的计算。对应的完成代码。

```cpp
int factorial(int n){
    if(n == 0)
        return 1;
	return n * factorial(n-1);
}
```

**4. 思考**

我们只有这样一种方式去递减数据规模吗？其实肯定不是。要计算$n!$，如果我们知道了$(n-2)!$行不行，其实真的行，因为$n! = (n-2)! * (n-1) * n$。那么问题来了，如何计算$n-2$的阶乘呢？其实还是调用`factorial(n-2)`就完事了。这里我又要说出递归的精髓，放弃思考。此时的代码应该如下。

```cpp
int factorial(int n){
    if(n == 0)
        return 1;
	return n * (n-1) * factorial(n-2);
}
```

如果按照这种递减策略的话，想一下递归退出的条件是不是应该改变。如果不变的话，当$n=1$时，就要调用到`factorial(-1)`，这样就不会跳出递归函数了。所以就要修改递归函数退出条件。

```cpp
int factorial(int n){
    if(n == 0 || n == 1)
        return 1;
	return n * (n-1) * factorial(n-2);
}
```

按照这种递减策略下去，当把阶乘公式写成$n! = n * (n-1) * (n-2) * factorial(n-3)$这种形式，递归的规模又减少了。如此递推下去，$n!=n*(n-1)*(n-2)*(n-3)*…*(n-(n-1))$，咦，仔细看看，这不就是阶乘的迭代写法嘛，所以阶乘的迭代写法如下。

```cpp
int factorial(int n){
    int res = 1;
    for(int i = n; i >= 1; i--)
        res *= i;
    return res;
}
```

虽然上面这个例子及其简单，但是我们还是要回顾一下。编写递归函数中的关键在于如何恰当的分割数据，因为不同分割数据的方法，不仅会影响到层与层之间的关系，还影响到递归退出的条件。

当把规模为$n$的分割成$1$和$n-1$时，`factorial(n)`层与`factorial(n-1)`之间的关系相差一个$n$。这个$n$就是两层之间的一个桥梁。递归函数的退出条件是`n=0`

当把规模为$n$的分割成$2$和$n-2$时，`factorial(n)`层与`factorial(n-2)`之间的关系相差一个$n*(n-1)$。这个$n*(n-1)$就是两层之间的一个桥梁。递归函数的退出条件是`n=0`或者`n=1`。

从上面的总结中我们可以看到，递归的核心就是**如何分割数据，以及找到层与层之间的关系。**



## 链表翻转 

但凡是讲到递归，和链表相关的，有一个经典的题就是链表翻转。但是这个题，一开始我是不理解如何使用递归去翻转链表的，但是当我慢慢熟悉了递归，我发现，用递归解决链表翻转，都能玩出花样。

比如有如下这个链表，经翻转后应该变成如下的样子

![](https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200410203127.png)

当然，由于这个第二个，就比较难了，所以还是按照写递归的三个步骤来解决这个问题。

### 递归解法1

**1. 定义递归函数`ListNode* reverseList(ListNode* head)`功能以及返回值**：

翻转以`head`为头节点的链表，并返回翻转后的链表的头节点。记住这个功能是我们自己定义的，是我们赋予它具有什么功能他就具有什么功能，随后我们就按照这个功能为前提，进行编写递归函数。

**2. 寻找递归函数的退出条件**

当链表中只有一个节点或者没有节点的时候，就不用翻转了，所以直接退出。

```cpp
if(head == nullptr || head->next == nullptr)
    return head;
```

**3. 拆分原数据，寻找层与层之间的关系**

假设我们要翻转的链表的长度是$n$，在这里，我们要怎么拆分数据呢？其实，只要按照上面的套路，我们想怎么拆就怎么拆。假设在这里，我们将其拆成$n-1$和$1$两个部分。拆分数据的代码。

```cpp
ListNode* newHead = head->next;
head->next = nullptr;
```



![](https://tva1.sinaimg.cn/large/007S8ZIlly1ge09f7zmtuj30q605kjrn.jpg)

按照上面的套路，对于$n-1$部分，仍然作为递归函数的参数。这时候$n-1$部分就已经完成了翻转，得到了我们期望的结构。记住那句话了没，这里千万不要想着为啥使用递归函数作用后就完成了$n-1$部分的翻转呢？而是直接用这个结论，和剩下没有参与递归的部分进行融合，使链表整体变成我们期望的答案。此时链表变成了如下图的样子。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1ge09l2uo2mj30ru05wgm1.jpg)

为了得到我们期望的样子，我们只需要将$n-1$部分和$1$的部分做一个简单的指针指向的改变，就完成了链表的翻转。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1ge09pzvegjj30s005g74o.jpg)

所以将核心部分写成代码

```cpp
ListNode* retHead = reverseList(newHead);
newHead->next = head;
head->next = nullptr;
return retHead;
```

所以说，只要我们放弃了对于为啥`reverseList(newHead)`就可以完成链表的翻转，我们就可以顺利写出递归的代码了。

当然，还有更多的骚操作吗？其实当然可以有更骚的操作。

-   完整代码

```cpp
ListNode* reverseList(ListNode* head) {
    //当链表中只有一个节点或者没有节点的时候，直接退出
    if(!head || !head->next)
        return head;
    //分成两个部分
    ListNode* newHead = head->next;
    head->next = nullptr;
    //完成 k - 1 部分的翻转
    ListNode* retHead = reverseList(newHead);
    //修改指针，是最后一部分完成翻转
    newHead->next = head;
    head->next = nullptr;
    return retHead;
}
```

### 递归解法2

上面我们将原来的数据规模$n$拆分成$n-1$和$1$两个部分，现在换种解法，将$n$拆分成$n/2$和$n/2$两个部分，看下和上面解法的不同。

对于编写递归的第一步和第二步，

想要拆分成$n/2$和$n/2$，第一个问题就是如何定位到链表的中点。坐下，这当然都是常规操作了，当然是使用快慢指针了，快指针一次走两步，慢指针一次走一步。当快指针到达链表终点时，慢指针就走到了中点，此中点非彼终点。虽然使用快慢指针原理很简单，但是还是要注意下细节的。把它写成代码。

```cpp
ListNode* fast = head;
ListNode* slow = head;
ListNode* mid = NULL;
while(fast && fast->next) //访问fast->next之前要保证fast本身不为空
{
    fast = fast->next->next;
    mid = slow;
    slow = slow->next;
}
mid->next = NULL;
```

其中`head`、`mid`、`slow`三个指针的指向如下所示。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1ge0b2lfyhaj30ps05maac.jpg)

接下来的步骤还用我说嘛，当然是使用`head`和`slow`分别作为递归函数的参数，就分别完成了链表两个部分的翻转。大声告诉我，这里的台词是什么？请放弃思考为什么递归函数就可以完成`head`和`slow`两个部分的翻转。而是在完成了翻转的基础上，再进行数据的融合。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1ge0bebexxxj30qk05smxi.jpg)

写成代码，并更改`slow->next`的指针指向`ret1`即可。

```cpp
ListNode* ret1 = reverseList(head);
ListNode* ret2 = reverseList(slow);
slow->next = ret1;
return ret2;
```

这样是不是就大功告成了。

当然还有不止这两种数据拆分的方式，还有更多的精彩拆分方式，我们再来看一种。

-   完成代码

```cpp
ListNode* reverseList(ListNode* head) {
    if(!head || !head->next)
        return head;

    ListNode* fast = head;
    ListNode* slow = head;
    ListNode* mid = NULL;
    while(fast && fast->next)
    {
        fast = fast->next->next;
        mid = slow;
        slow = slow->next;
    }
    mid->next = NULL;
    ListNode* ret1 = reverseList(head);
    ListNode* ret2 = reverseList(slow);
    slow->next = ret1;
    return ret2;
}
```

### 递归解法3

既然我们知道了递归的套路，干脆再换种拆分数据的方式，这次我们将数据规模为$n$拆分成$n-2$和$2$这两个部分。我们来看下，这种拆分方式，和前面的解法有什么不同。

**递归函数的退出条件**

首先我们定义的递归函数的功能是不变的，但是对于递归的退出条件是应该改变的，应该变成什么呢？

>   如果只有一个节点或者没有节点的时候，就应该直接退出。
>
>   如果只有两个节点的时候，就翻转这两个节点。

所以写成代码

```cpp
if(head == nullptr || head->next = nullptr)
    return head;
if(head->next->next == nullptr)
{
    ListNode* retNode = head->next;
   	retNode->next = head;
    head->next = nullptr;
    return retNode;
}
```

**分割数据，寻求层与层之间的关系**

对于数据规模大于$2$的时候，就应该进入到递归中了，所以首先我们将链表分为$n-2$和$2$两个部分。分割代码

```cpp
ListNode* node2 = head->next->next;
head->next->next = nullptr;
```

![](https://tva1.sinaimg.cn/large/007S8ZIlly1ge0hj0qa4tj30s405e0sz.jpg)

接下来数据规模为$n-2$的数据作为递归函数的参数，当递归函数作用后，$n-2$部分就完成了链表的翻转。这时候大声告诉我，此时应该做什么。此时应该做的是，放弃思考为什么递归函数就可以完成链表的翻转，而是再翻转的基础上，和没有参与递归的部分进行融合。

![](https://tva1.sinaimg.cn/large/007S8ZIlly1ge0ho865f4j30sa05oweu.jpg)

此时只要改变指针的指向就可以了。写成代码如下。

```cpp
ListNode* retHead = reverseList(node2);
ListNode* node1 = head->next;
node2->next = node1;
node1->next = head;
head->next = nullptr;
return retHead;
```

-   完整代码

```cpp
ListNode* reverseList(ListNode* head) {
    if(head == nullptr || head->next == nullptr)
        return head;
    if(head->next->next == nullptr)
    {
        ListNode* retHead = head->next;
        retHead->next = head;
        head->next = nullptr;
        return retHead;
    }
    ListNode* node2 = head->next->next;
    head->next->next = nullptr;
    ListNode* retHead = reverseList(node2);
    ListNode* node1 = head->next;
    node2->next = node1;
    node1->next = head;
    head->next = nullptr;
    return retHead;
}
```

### 思考

当我们总结一下当把递归的规模分为$n-1$和$n-2$部分时，在编写代码的时候，几乎可以看到有重复的操作，比如让`newHead->next = head`和`head->next = nullptr`。我们可以看到，链表的翻转就是将，此节点的`next`指针指向上一个节点，但是再改变之前要保存此节点的下一个节点，如此循环到最后一个节点。这就是链表翻转的核心。所以写成迭代代码如下：

```cpp
ListNode* reverseList(ListNode* head){
    ListNode* pre = nullptr;
    ListNode* cur = head;
    while(cur){
        //先保存下一个节点
        ListNode* next = cur->next;
        //更改指针
        cur->next = pre; 
        //同时向后一位
        pre = cur;
        cur = next;
    }
    return pre;
}
```

由于链表的天然特性，对于链表的很多问题其实都是可以用递归解决的。比如要改变链表的结构、在链表中删除元素、甚至是链表的合并和排序问题。但是用递归解决链表的核心问题就是如何划分链表为两个部分或者更多部分，以及处理层与层之间的关系。当然在编写链表有关问题的时候，要仔细处理指针问题，尤其是访问某个节点的值时，要确定此节点不为空。这点尤其容易出错。

有关使用递归解决链表的问题，请看我的解题。

## 汉诺塔

有关汉诺塔的问题，我真的不想介绍太多了。想必知道递归的应该都应该有过被汉诺塔支配的恐惧吧。

汉诺塔真的是童年的一个经典的小游戏，我记得当时在某一款学习机上就有这个益智游戏，不过当时我还是凭借自己出色的智商把游戏玩到了第四关，并且那时候我就知道，如果想要移动四层，只要把前三层的都移动另外一个柱子上就行了，剩下的就和两个盘子的是一个道理。

那时候，我就有一种强烈的想法就是，这个东西一定是有一定的步骤的和规律的，但是这个步骤我要怎么才能生成呢？

这个问题直到我大学一年级学了C语言并且知道了递归之后，才知道这个要用递归解决，但是无论如何，我都不知道为啥要这么写递归。直到现在，我放弃了理解递归，才真正的能够编写出汉诺塔的代码。

![img](/Users/mengxiangpeng/Desktop/递归.assets/1026866-20161016022859889-2055402664.jpg)

假设我们要编写一个函数`TowersOfHanoi(int n, char A, char B, char C)`实现借助B柱将n个汉诺塔从A移动到C。我们还是按照编写递归的三个步骤：

1.  定义递归函数`TowersOfHanoi(int n, char A, char B, char C)`功能：借助B柱，将n个汉诺塔从A移动到C上。也就是说，第一个变量是柱子的起点，中点的变量是枢纽站，最后一个变量才是终点。

2.  递归函数的退出条件：

    当只有一个盘子的时候，直接从A移动到C就行了。写成代码

    ```cpp
    if(n == 1)
    {
        move(1, A, C);
        return ;
    }
    ```

3.  分割数据，找到层与层之间的联系。

    想一下，如果我们只想移动最后一个盘子，就是说将第$n$个盘子看成一个，其余的$n-1$个盘子看成一个，就相当于有两个盘子。我们的步骤应该是这样。

    >   1.  借助C盘，把A柱子上的$n-1$个盘子全部移动到B盘。
    >
    >   2.  将A柱子上第$n$个盘子，直接移动到C盘。
    >
    >   3.  借助A盘，把在B柱子上的$n-1$个盘子移动到C盘。

    仔细分析一下上面的三步，是不是有借助某柱把多少个盘子从某柱移动到某柱上，这是啥，这不就是递归函数的定义嘛。所以按照我们定义的功能，将上面三句话写成代码。

    ```cpp
    //明确函数的定义，第一个变量是盘子的起点，中间的变量是盘子的枢纽站，最后一个变量表示的是盘子的终点
    TowersOfHanoi(n-1, A, C, B);  
    move(n, A, C);
    TowersOfHanoi(n-1, B, A, C);
    ```

    接下来分析，为什么调用`TowersOfHanoi(n-1, A, C, B)`就完成了借助C将$n-1$个盘子从A移动到B了呢？这里的台词是，我们定义的递归函数功能就是这么定义的，不要去想这个具体是怎么实现的，而是直接使用这个结论就行了，此乃编写递归函数的精髓。放弃思考。

    至于`move(int n, char from, char to)`函数的实现：

    ```cpp
    void move(int n, char from, char to){
        printf("%d  %c -->> %c", n, from, to);
    }
    ```

-   完整代码

    ```cpp
    inline void move(int n, char from, char to){
        printf("%d  %c -->> %c\n", n, from, to);
    }
    //明确函数的定义，第一个变量是盘子的起点，中间的变量是盘子的枢纽站，最后一个变量表示的是盘子的终点
    void TowersOfHanoi(int n, char A, char B, char C)
    {
        if(n == 1)
        {
            move(1, A, C);
            return ;
        }
        TowersOfHanoi(n-1, A, C, B);
        move(n, A, C);
        TowersOfHanoi(n-1, B, A, C);
    }
    ```

    当`n=3`时，执行的结果如下：

    ```tex
    1  A -->> C
    2  A -->> B
    1  C -->> B
    3  A -->> C
    1  B -->> A
    2  B -->> C
    1  A -->> C
    ```

### 思考

对于上面的移动过程，只要我们明确了递归函数的功能，就可以写出更加复杂的代码，比如我们定义移动盘子的流程是这样的。

>   1.  借助C盘，把A柱子上的$n-1$个盘子全部移动到B盘。
>
>   2.  将A柱子上第$n$个盘子，直接移动到C盘。
>
>   3.  借助C盘，把在B柱子上的$n-1$个盘子重新移动回到A盘。此时有n-1个盘子在A柱子上，1个盘子在C柱子上。
>   4.  重新借助B，将A柱子上的$n-1$个盘子移动到C盘。

写成代码：

```cpp
TowersOfHanoi(n-1, A, C, B);
move(n, A, C);
TowersOfHanoi(n-1, B, C, A);
TowersOfHanoi(n-1, A, B, C);
```

这样的做法虽然移动的步骤增加了，但是还是可以实现功能的，只不过在这里为了让大家体会编写递归函数的功能，就增加了这样一个重复的做法。

当`n=3`时，执行的记过如下：

```tex
1  A -->> C
2  A -->> B
1  C -->> A
1  A -->> B
3  A -->> C
1  B -->> C
2  B -->> A
1  C -->> B
1  B -->> A
1  A -->> B
2  A -->> C
1  B -->> A
1  A -->> C
```

从执行的结果可以看出，有很多步骤是多余的，但是为了让大家更好的理解递归函数执行的过程，就增加了这个画蛇添足的过程。

上面的是将$n$个盘子拆分成$n-1$和$1$两个部分，如果我们再换一种拆分数据的方式，我们将$n$个盘子拆分成$n-2$和$2$，那么递归的过程又是怎么样的呢？这个过程其实还是蛮复杂的，到现在为止，我都没有想到怎么移动才比较好，所以我就把$n$个汉诺塔拆分成$1$和$n-1$两个部分，至于其余的拆分方式，我暂时还没想出来。

至于前面的两道题，我都一步一步改变拆分数据的方式，进而引出迭代的写法，不过至于汉诺塔迭代的写法，我还没有搞清楚$n-2$和$2$怎么用低柜编写，所以对于迭代写法，我自然写不出来。不过随着深入，我相信我可以把这里补充起来。

# 递归函数的退出条件不容小觑

经过了上面一节的训练，我认为你已经搞定了递归三个步骤中的两个步骤，并且掌握了要点，分割数据并且找到层与层之间的关系，却忽略了另外一个问题。函数的递归退出条件，因为一般情况下，这点一般都是很容易看出来。所以这里找两个例题，感受下递归函数的退出条件依然不容小觑。

### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

**示例：**
给定二叉树 `[3,9,20,null,null,15,7]`，

```
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3 。

这是一个树的问题，所以我们采用递归的方式进行求解。

1.  定义递归函数`int maxDepth(TreeNode* root)`的功能和返回值：计算以`root`为根的二叉树的高度，并返回。

2.  递归函数的退出条件。当`root`为空的时候，高度为0，写成代码。

    ```cpp
    if(root == nullptr)
        return 0;
    ```

3.  分割数据，找到层与层之间的关系

    想一下，我们拿到一个树的某一个节点的时候，我们能干嘛，无非就是四件事。

    >   1.  啥也不干
    >   2.  访问左子树
    >   3.  访问右子树
    >   4.  取出或者设置该节点的值

    所以在这里我们分层的依据很简单，就是访问左子树或者访问右子树。

    ```cpp
    int left = maxDepth(root->left);
    int right = maxDepth(root->right);
    ```

    用递归函数重新作用了左子树和右子树，这个函数的返回结果就是左子树的告诉或者是右子树的高度，因为我们定义的函数的功能就是计算以`root`为根的树的高度，至于为什么这个函数可以计算，请放弃。我们要在的到了左子树和右子树高度的基础上，计算`root`节点的高度，所以以`root`为根的树的高度为`1+ max(left, right)`。

    写成代码：

    ```cpp
    int maxDepth(TreeNode* root) {
        if(!root)
            return 0;
        return 1+max(maxDepth(root->left), maxDepth(root->right));
    }
    ```

    这个问题很很简单的，我们来看下另外一个问题。

### [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明: 叶子节点是指没有子节点的节点。

示例:

给定二叉树 [3,9,20,null,null,15,7],

        3
       / \
      9  20
        /  \
       15   7
返回它的最小深度  2.

这题一看，还是递归求解，按照递归的三个步骤：

1.  定义函数`int minDepth(TreeNode* root)`为计算以`root`为根的二叉树的最小深度。

2.  递归函数的返回值，如果没有节点，返回0。

    ```cpp
    if(root == nullptr)
        return 0;
    ```

3.  分割数据，并且找到层与层之间的关系

    这个很简单啊，还是仿照上题的做法，写下了如下的代码：

    ```cpp
    int left = minDepth(root->left);
    int right = minDepth(root->right);
    return 1 + min(left, right);
    ```

    至于其中的道理我就不解释了，准备提交，一个错误就返回。

    当测试用例为如下结构时，应该返回2

    ![](https://cdn.jsdelivr.net/gh/jackymxp/image-bed/leetcode/20200421100756.png)

    这时候不得不让我头皮发麻，这个错在了哪里呢，我们回头再看下题目。我们突然发现了这样一句话，从根节点到最近的叶子节点的路径。而在我们的代码中，根本就没有体现出叶子节点这一概念。问题就出在了当右子树或者左子树为空的情况下，所以我们再次思考递归的退出条件是什么？

    当左子树为空的时候，应该返回的是右子树的最小高度加1

    当右子树为空的时候，应该返回的是左子树的最小高度加1

    当左右子树都不为空的时候，应当返回左右子树最小高度的最小值。

    所以，将上述递归退出条件写成代码：

    ```cpp
    if(root->right == nullptr)
        return 1 + minDepth(root->left);
    if(root->left == nullptr)
        return 1 + minDepth(root->right);
    ```

-   完成代码

    ```cpp
    int minDepth(TreeNode* root){
        if(root == nullptr)
            return 0;
        //叶子节点
        if(root->left == nullptr && root->rigth == nullptr)
            return 1;
        if(root->left == nullptr)
            return 1 + minDepth(root->right);
        if(root->right == nullptr)
            return  1 + minDepth(root->left);
        return 1+min(minDepth(root->left), minDepth(root->right));
    }
    ```

#### 思考

上面的两个题，其核心代码都是相同的结构，但是不同的地方在于其函数的退出条件。通过这两个例子，想说明的是，有时候递归函数的退出条件并不是我们想象的那样简单，还需要仔细的加以思考，这样才能写出完整的代码。

# 总结

磨磨唧唧写了这么多，也不知道我自己写没写清楚关于如何编写递归函数。在这里重新温习一下递归的要点，如何将数据分层，并找到层与层之间的关系。在缩放函数规模的时候，千万不要陷入到递归函数内部去，及时止损，及时放弃，才能清醒的写出递归的代码。最后想起苏轼的一句诗，我觉得形容递归也很对。

>   不识庐山真面目
>
>   只缘身在此山中

对于如何分割数据，其实没有固定的套路，但是不同的分割数据的方式，对应的函数的退出条件也是不同的，这一点要考虑清楚。

当然对于低柜函数的退出条件也是不能小看的，在特殊情况下，一定要好好斟酌。

最后，上面写了三点，如何编写递归函数的核心，还有最后一点没有交代清楚。那么在这里放出最重要的一点，如果你看懂了如何编写递归，那么请关注我的公众号，以满足我的虚荣心，鼓励我做出更多作品。

如果你没有看懂递归，在我的公众号中，还有更多和递归相关的话题，包括专门使用递归解决`leetcode`上的有关链表的专题，树的专题，甚至是从递归到动态规划的专题。让你一次，弄懂递归。